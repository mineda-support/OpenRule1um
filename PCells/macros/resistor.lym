<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>Resistor PCell</description>
 <version/>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>true</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>ruby</interpreter>
 <dsl-interpreter-name/>
 <text> module MyLib

  include RBA

  # Remove any definition of our classes (this helps when 
  # reexecuting this code after a change has been applied)
  MyLib.constants.member?(:Resistor) &amp;&amp; remove_const(:Resistor)
  MyLib.constants.member?(:MyLib) &amp;&amp; remove_const(:MyLib)
  
  # The PCell declaration for the OpenRule1um resistor 
  class Resistor &lt; PCellDeclarationHelper
  
    include RBA

    def initialize

      # Important: initialize the super class
      super

      # declare the parameters
      param(:l, TypeDouble, "Resistor length", :default =&gt; 10.0.um)
      param(:w, TypeDouble, "Resistor width", :default =&gt; 1.0.um)
      param(:n, TypeInt, "Number of maximum foldings", :default =&gt; 0)

      param(:rval, TypeDouble, "Resistor value", :default =&gt; 0, :hidden=&gt; true)

    end
  
    def display_text_impl
      # Provide a descriptive text for the cell
      "Resistor\r\n(L=#{l.to_s}um,W=#{w.to_s}um,n=#{n.to_s}, R=#{rval})"
    end
    
    def coerce_parameters_impl
    
      # We employ coerce_parameters_impl to decide whether the handle or the 
      # numeric parameter has changed (by comparing against the effective 
      # radius ru) and set ru to the effective radius. We also update the 
      # numerical value or the shape, depending on which on has not changed.
      sheet_resistance = 300
      set_rval(sheet_resistance * l / w)
=begin
      rs = nil
      if s.is_a?(DPoint) 
        # compute distance in micron
        rs = s.distance(DPoint::new(0, 0))
      end 
      if rs &amp;&amp; (r-ru).abs &lt; 1e-6
        set_ru rs
        set_r rs 
      else
        set_ru r 
        set_s DPoint::new(-r, 0)
      end
      
      # n must be larger or equal than 4
      n &gt; 4 || (set_n 4)
=end       
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def parameters_from_shape_impl
=begin
      # 「Create PCell from shape(図形からPCellを作成)」プロトコルを実装します。
　    # シェイプのバウンディングボックスの幅とレイヤーからrとlを設定します。
      set_r shape.bbox.width * layout.dbu / 2
      set_l layout.get_info(layer)
=end
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end
    
    def produce_impl
    
      rw = (w/layout.dbu).to_i
      rl = (l/layout.dbu).to_i
      s = 2.0.um # via size (fixed)
      vs = (s/layout.dbu).to_i
      space = 5.0.um # space between HPOL
      sp = (space/layout.dbu).to_i
      grid = 1.0.um
      
      sl = ((l.to_i/(n+1))/layout.dbu).to_i
      if sl*(n+1) == rl
        r = 0
 #     elsif sl*(n+1) &lt; rl
 #       r = rl - sl*(n+1)
      else
        sl = sl + (grid/layout.dbu).to_i
        r = rl - sl*n
        set_n n - 1 if r &lt;= 0
      end
      puts "rl = #{rl}, n+1 = #{n+1}, sl = #{sl}, r = #{r}"
      
      hpol_index = layout.insert_layer(LayerInfo::new(6, 0))
      ml1_index = layout.insert_layer(LayerInfo::new(8, 0))
      via_index = library_cell('Via', 'OpenRule1um', layout)
      pcont_index = library_cell('pcont', 'OpenRule1um', layout)
      prev_x = nil
      for i in 0..n
        offset = vs/2 + (sp+(w/layout.dbu).to_i)*i
        r = sl
        if rl - sl*(i+1) &lt; 0
          r = rl - sl*i
        end
        puts "offset=#{offset}, r=#{r} for i=#{i}"

        if i % 2 == 0
          points = [Point::new(offset, vs), Point::new(offset, vs+r)]
          cell.shapes(hpol_index).insert(Path::new(points, rw, vs, vs))
          [[offset, vs/2], [offset, r+vs+vs/2]].each{|x, y|
            insert_via_pcont via_index, pcont_index, x, y, cell
          }
          if prev_x
            points = [Point::new(offset, vs/2), Point::new(prev_x, vs/2)]
            cell.shapes(ml1_index).insert(Path::new(points, vs, vs/2, vs/2))
          end  
        else
           points = [Point::new(offset, vs+(sl-r)), Point::new(offset, vs+sl)]
          cell.shapes(hpol_index).insert(Path::new(points, rw, vs, vs))
          [[offset, vs/2+(sl-r)], [offset, sl+vs+vs/2]].each{|x, y|
            insert_via_pcont via_index, pcont_index, x, y, cell
          }
          if prev_x
            points = [Point::new(offset, sl+vs+vs/2), Point::new(prev_x, sl+vs+vs/2)]
            cell.shapes(ml1_index).insert(Path::new(points, vs, vs/2, vs/2))
          end
        end         
        prev_x = offset  
      end
    end
    
    def library_cell name, libname, layout
      if cell = layout.cell(name)
        return cell.cell_index
      else
        lib = Library::library_by_name libname
        cell_index = lib.layout.cell_by_name(name)
        proxy_index = layout.add_lib_cell(lib, cell_index)
      end
    end
    
    def insert_via_pcont via_index, pcont_index, x, y, cell
      via = instantiate via_index, x, y, cell
      inst = cell.insert(via)
      pcont = instantiate pcont_index, x, y, cell
      inst = cell.insert(pcont)
    end
   
    def instantiate index, x, y, cell
      CellInstArray.new(index, Trans.new(x, y))
    end
  end
    # PCellを配置するライブラリ 
  class MyLib &lt; Library
  
    def initialize  
    
      # 説明を設定
      self.description = "OpenRule1um Library"
      
      # PCell宣言を作成する
      layout.register_pcell("Resistor", Resistor::new)
      # それはより多くのPCellを置くための場所でしょう...
      
      # "MyLib"という名前で登録します。
      # その名前のライブラリがすでに存在していた場合は、その時点で置き換えられます。
      register("MyLib")
      
    end
  
  end
  
  # ライブラリをインスタンス化して登録する
  MyLib::new
  
end
</text>
</klayout-macro>
