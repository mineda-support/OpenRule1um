<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>Common macro library for PCells</description>
 <version/>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>ruby</interpreter>
 <dsl-interpreter-name/>
 <text># coding: utf-8
# MinedaPCell v0.591 August 24th 2022 copy right S. Moriyama (Anagix Corporation)
# 
module MinedaPCell
  version = '0.591'
  include RBA
  class MinedaPCellCommon &lt; PCellDeclarationHelper
    include RBA
    attr_accessor :defaults, :layer_index
    @@lyp_file = @@basic_library = @@layer_index = nil
    def initialize 
      key = 'PCells_' + self.class.name.to_s.split('::').first + '-defaults'
      @defaults = YAML.load(Application.instance.get_config key)
      # puts "Got PCell @defaults from #{key}"
      set_layer_index
      super
    end
       
    def set_technology tech_name
      tech = RBA::Technology::technology_by_name(tech_name)
      @@lyp_file = File.join tech.base_path, tech.layer_properties_file
      @@layer_index = get_layer_index_from_file @@lyp_file
    end
     
    def set_basic_library basic_lib
      @@basic_library = basic_lib
    end
    
    def get_layer_index_from_file lyp_file
      return unless lyp_file
      require 'rexml/document'
      doc = REXML::Document.new(File.open(lyp_file))
      layer_index = {}
      doc.elements.each('layer-properties/properties'){|e|
        name = e.get_text('name').to_s.sub(/\(.*$/, '')
        e.get_text('source').to_s =~ /([0-9]+)\/([0-9]+)/
        index = $1.to_i
        data_type = $2.to_i
        layer_index[name] = [index, data_type]
      }
      # puts layer_index
      layer_index
    end
    
    def set_layer_index
      @basic_library = @@basic_library
      @layer_index = @@layer_index
    end
    
    def get_layer_index name
      layer, data_type = @layer_index[name]
      layout.insert_layer(LayerInfo::new layer, data_type)
    end
    
    def get_cell_index name
      library_cell name, @basic_library, layout
    end    
    
    def param name, type, desc, last_resort
      cellname = self.class.name.to_s.split('::').last.to_s
      if @defaults &amp;&amp; @defaults[cellname]
        if (value = @defaults[cellname][name.to_s]) || (value == nil) || (value == false)
          # puts "#{self.class.name} '#{name}' =&gt; #{value}"
          if last_resort[:default] == true
            super name, type, desc, {default: value}         
          else
            super name, type, desc, value ? {default: value} : last_resort
          end        
        elsif value = @defaults[cellname][name.to_s + '_hidden']
          # puts "#{self.class.name} '#{name}' =&gt; #{value} 'hidden' =&gt; true"
          super name, type, desc, value ? {default: value, hidden: true} : last_resort
        else
          super name, type, desc, value ? {default: value} : last_resort     
        end
      else
        super name, type, desc, last_resort
      end
    end
     
    def library_cell name, libname, layout
      if cell = layout.cell(name)
        return cell.cell_index
      else
        lib = Library::library_by_name libname
        if lib &amp;&amp; cell = lib.layout.cell(name)
          proxy_index = layout.add_lib_cell(lib, cell.cell_index)
        end
      end
    end

    def create_box index, x1, y1, x2, y2
       cell.shapes(index).insert(Box::new(x1, y1, x2, y2))
    end
    
    def insert_cell via_index, x, y, rotate=false
      via = CellInstArray.new(via_index, rotate ? Trans.new(1, false, x, y) : Trans.new(x, y))      
      inst = cell.insert(via)
    end

    def create_path index, x1, y1, x2, y2, w, be, ee
      points = [Point::new(x1, y1), Point::new(x2, y2)]
      cell.shapes(index).insert(Path::new(points, w, be, ee))
    end
    
    def create_path2 index, x1, y1, x2, y2, x3, y3, w, be, ee
      points = [Point::new(x1, y1), Point::new(x2, y2), Point::new(x3, y3)]
      cell.shapes(index).insert(Path::new(points, w, be, ee))
    end
    
    def create_dcont index, x1, y1, x2, y2, vs
      (y1+vs/2..y2-vs/2).step(vs){|y|
        insert_cell index, x1, y
      }
    end
  end
  
  # The PCell declaration for the Mineda MOSFET
  class MinedaMOS &lt; MinedaPCellCommon
  
    include RBA
    def initialize
      # Important: initialize the super class
      super
      param(:n, TypeInt, "Number of fingers", :default =&gt; 1)
    end

    def coerce_parameters_impl
    
      # We employ coerce_parameters_impl to decide whether the handle or the 
      # numeric parameter has changed (by comparing against the effective 
      # radius ru) and set ru to the effective radius. We also update the 
      # numerical value or the shape, depending on which on has not changed.
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def parameters_from_shape_impl
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end
    
    def coerce_parameters_impl
      set_wtot(w*n)
    end
    
    def produce_impl_core indices, vs, u1, params = {}
      gw = (w/layout.dbu).to_i
      gl = (l/layout.dbu).to_i
      vo = params[:vs_overhead] || 0
      dgl = ((dg || 0.0)/layout.dbu).to_i
      if gw &lt; vs - vo  # dgl: dumbbell gap length
        dgl = [dgl, ((dsl/layout.dbu).to_i - gl)/2].max if defined? dsl # dsl: minimum dumbbell shaft length
      else 
        dgl = [dgl,  ((sdg/layout.dbu).to_i - gl)/2].max if defined? sdg # sdg: minimum source-drain gap
      end
      xshift = params[:xshift] || vs/2
      yshift = params[:yshift] || vs/2
      u1cut = params[:u1cut] || 0
      gate_ext = params[:gate_ext] || vs/2 + u1/8
      offset = 0
      (n+1).times{|i|
        x = offset + vs/2 - xshift
        create_path(indices[:m1], x, vs-yshift+u1, x, vs-yshift+u1-u1cut+[gw, vs].max, vs, 0, 0)
        create_path(indices[:li1], x, vs-yshift+u1, x, vs-yshift+u1-u1cut+[gw, vs].max, u1, 0, 0) if indices[:li1]
        create_dcont(indices[:dcont], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, vs)  
        x = x + vs/2 + gl/2 + dgl
        if i &lt; n
          create_path(indices[:pol], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, gl, gate_ext, gate_ext) 
          if indices[:gate_impl]
            gim = params[:gate_impl_margin] || vs/2
            create_path(indices[:gate_impl], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, gl+gim*2, gate_ext+gim, gate_ext+gim) 
          end
        end
        offset = offset + vs + gl + 2*dgl
      }
      if gw &gt; vs
        create_box indices[:diff], -xshift, vs-yshift+u1, offset - gl - 2*dgl - xshift, vs-yshift+u1-u1cut+gw
      else
        create_box indices[:diff], -xshift, vs-yshift+u1+vs/2-gw/2, offset - gl - 2*dgl - xshift, vs-yshift+u1-u1cut+gw+vs/2-gw/2
      end   
      yield -xshift, -yshift, vs*2+gl-xshift, (vs+u1)*2+[gw, vs].max-yshift, gl, dgl
    end
    
    def library_cell name, libname, layout
      if cell = layout.cell(name)
        return cell.cell_index
      else
        lib = Library::library_by_name libname
        cell_index = lib.layout.cell_by_name(name)
        proxy_index = layout.add_lib_cell(lib, cell_index)
      end
    end
  end

  class MinedaNch &lt; MinedaMOS
    include RBA
    
    def display_text_impl
      "Nch\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,n=#{n.to_s},Total W=#{wtot.round(3)}um)"
    end 
       
    def produce_impl indices, vs, u1, params = {} # NMOS
      produce_impl_core(indices, vs, u1, params){|x1, y1, x2, y2, gl, dgl|
        # create ncon
        wm_offset = wide_metal ? u1 : 0
        x = x1 + vs/2
        pcont_dy = params[:pcont_dy] || u1/4
        y = y2 - vs/2 + pcont_dy
        gate_ext = params[:gate_ext] || 0
        if wide_metal
          x = x - u1
          y = y + u1/2 
        end
        if with_pcont
          pol_width = params[:pol_width] || u1 + u1/4
          if n == 1 &amp;&amp; !with_sdcont
            insert_cell indices[:pcont], x1+vs+dgl+gl/2, y
            insert_cell indices[:via], x1+vs+dgl+gl/2, y if with_via
            create_path indices[:pol], x1+vs+dgl+gl/2, y, x1+vs+dgl+gl/2, y2-vs + gate_ext - u1, pol_width, 0,0
          else
            insert_cell indices[:pcont], x, y
            insert_cell indices[:via], x, y if with_via
            y = y - u1/2
            create_path2 indices[:pol], x, y, x1+vs+u1/2+dgl, y, x1+vs+u1/2+dgl, y2-vs + gate_ext - u1, pol_width, 0, 0
          end
        end
        offset = x1
        top = nil
        bottom = nil
        prev_pol = nil
        (n+1).times{|i|
          x = offset + vs/2
          y = y2 - vs + u1/2 + gate_ext - u1
          create_path indices[:pol], prev_pol-vs/2-gl-dgl, y , x-vs/2-dgl, y, u1, 0, 0 if prev_pol
          prev_pol = x if i &gt;= 1
          if i % 2 == 0
            # first s/d and via
            y = y1+vs/2 - wm_offset
            if with_sdcont || n != 1
              insert_cell indices[:via], x, y if with_via &amp;&amp; with_sdcont
              create_path indices[:m1], x, y, x, y1+vs+2*u1, u1, 0, 0
            end
            if top
              create_path indices[:m1], top, y, x, y, u1, u1/2, u1/2
            end
            top = x
          else
            # second s/d and via
            if n == 1
              insert_cell indices[:via], x, y2-vs/2 + (wide_metal ? u1/2 : 0) if with_via &amp;&amp; with_sdcont
              y = y2-vs/2
            else
              insert_cell indices[:via], x, y2+u1-vs/2 if with_via &amp;&amp; with_sdcont
              y = y2+u1-vs/2
            end
            create_path indices[:m1], x, y2-vs-2*u1 - wm_offset, x, y, u1, 0, 0 if with_sdcont || n != 1
            if bottom
              y = y2+u1-vs/2
              create_path indices[:m1], bottom, y, x, y, u1, u1/2, u1/2
            end
            bottom = x
          end
          offset = offset + vs + gl + 2*dgl
        }
        offset = offset - 2*dgl
        # psubcont and via
        psubcont_dx = params[:psubcont_dx] || 0
        psubcont_dy = params[:psubcont_dy] || u1/2 + u1
        x = offset - gl - vs/2 + (with_via ? u1/2 : u1/4) + psubcont_dx
        if with_psubcont &amp;&amp; use_pwell
          if n % 2 == 0
            y = y2 - vs/2 + psubcont_dy
          else
            y = y1 + vs/2 - psubcont_dy
            y = y - u1/2 if wide_metal
          end
          insert_cell indices[:psubcont], x, y if indices[:psubcont] 
          insert_cell indices[:via], x, y if with_via
        end
        #create_box indices[:narea], x1-u1, y1+vs+u1/2, offset-gl+u1, y2-vs-u1/2
        narea_bw = params[:narea_bw] || u1 + u1/4
        create_box indices[:narea], x1-narea_bw, y1+vs+u1-narea_bw, offset-gl+narea_bw, y2-vs-u1+narea_bw
        create_box indices[:lvhvt], x1-narea_bw, y1+vs+u1-narea_bw, offset-gl+narea_bw, y2-vs-u1+narea_bw if indices[:lvhvt]
        create_box indices[:nhd], x1-narea_bw, y1+vs+u1-narea_bw, offset-gl+narea_bw, y2-vs-u1+narea_bw if indices[:nhd] # special for PTS06  
        if indices[:nex]
          delta = params[:nex_delta] || u1*5
          create_box indices[:nex], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1
          delta = delta + delta
          create_box indices[:ar], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:ar]
        end
         if indices[:pwl] &amp;&amp; use_pwell
           if one = params[:pwl_bw] #        one = u1*6.25
             if indices[:nex]
               create_box indices[:pwl], x1-delta-one, [y1+vs-u1/2-delta-u1-one, y2-vs+u1/2+delta+u1-4*one].min,
                     [offset-gl+delta+one, x1-delta+4*one].max, y2-vs+u1/2+delta+u1+one
             else
               create_box indices[:pwl], x1-delta-one, y1+vs+u1-delta-one, offset-gl+delta+onr, y2-vs-u1+delta+one
             end
           end
        end
      }
    end
  end
  
  class MinedaPch &lt; MinedaMOS
    include RBA
    
    def display_text_impl
      "Pch\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,n=#{n.to_s},Total W=#{wtot.round(3)}um)"
    end
        
    def produce_impl indices, vs, u1, params = {} # PMOS
      produce_impl_core(indices, vs, u1, params){|x1, y1, x2, y2, gl, dgl|
        # create pcont
        wm_offset = wide_metal ? vs/2 : 0
        x = x1 + vs/2
        pcont_dy = params[:pcont_dy] || -u1/4
        y = y1 + vs/2 + pcont_dy
        gate_ext = params[:gate_ext] || 0
        if wide_metal
          x = x - u1
          y = y - u1/2
        end
        if with_pcont
          pol_width = params[:pol_width] || u1 + u1/4
          if n == 1 &amp;&amp; !with_sdcont
            insert_cell indices[:pcont], x1+vs+dgl+gl/2, y
            insert_cell indices[:via], x1+vs+dgl+gl/2, y if with_via
            create_path indices[:pol], x1+vs+dgl+gl/2, y, x1+vs+dgl+gl/2, y1+vs, pol_width, 0,0
          else
            insert_cell indices[:pcont], x, y
            insert_cell indices[:via], x, y if with_via
            y = y + u1/2
            create_path2 indices[:pol], x, y, x1+vs+u1/2+dgl, y, x1+vs+u1/2+dgl, y1+vs - gate_ext + u1, pol_width, 0, 0
          end
        end
        offset = x1
        top = nil
        bottom = nil
        prev_pol = nil
        (n+1).times{|i|
          x = offset + vs/2
          y = y1 + vs - u1/2 - gate_ext + u1 ### y1 + u1/2 + vs/2 # 
          create_path indices[:pol], prev_pol-vs/2-gl-dgl, y, x-vs/2-dgl, y, u1, 0, 0 if prev_pol
          prev_pol = x  if i &gt;=1   
          if i % 2 == 0
            # first s/d and via
            if with_sdcont || n != 1
              insert_cell indices[:via], x, y2-vs/2 + wm_offset if with_via &amp;&amp; with_sdcont
              create_path indices[:m1], x, y2-vs-2*u1, x, y2-vs/2 + wm_offset, u1, 0, 0
            end
            if top
              y = y2-vs/2 + wm_offset
              create_path indices[:m1], top, y, x, y, u1, u1/2, u1/2
            end
            top = x
          else
            # second s/d and via
            if n == 1
              insert_cell indices[:via], x, y1+vs/2 - (wide_metal ? u1/2 : 0) if with_via &amp;&amp; with_sdcont
              y = y1 + vs/2
            else
              insert_cell indices[:via], x, y1-u1+vs/2 if with_via &amp;&amp; with_sdcont
              y = y1-u1+vs/2
            end
            create_path indices[:m1], x, y, x, y1+vs+2*u1, u1, 0, 0 if with_sdcont || n != 1
            if bottom
              create_path indices[:m1], bottom, y1-u1+vs/2, x, y1 -u1+vs/2, u1, u1/2, u1/2
            end
            bottom = x
          end
          offset = offset + vs + gl + 2*dgl
        }
         # nsubcont and via
        if with_nsubcont &amp;&amp; use_nwell
          # nsubcont_dx = params[:nsubont_dx] || 0
          nsubcont_dy = params[:nsubcont_dy] ||  u1/2 + u1
          offset = offset - 2*dgl
          x = offset - gl - vs/2 + (with_via ? u1/2 : 0)
          if n % 2 == 0
            y = y1 + vs/2 - nsubcont_dy - (wide_metal ? u1 : 0)
          else
            y = y2 - vs/2 + nsubcont_dy + wm_offset
          end
          y = y + u1/2 if wide_metal
          insert_cell indices[:nsubcont], x, y if indices[:nsubcont] 
          insert_cell indices[:via], x, y if with_via
        end
        parea_bw = params[:parea_bw] || u1 + u1/4
        create_box indices[:parea], x1-parea_bw, y1+vs+u1-parea_bw, offset-gl+parea_bw, y2-vs-u1+parea_bw
        create_box indices[:lvhvt], x1-parea_bw, y1+vs+u1-parea_bw, offset-gl+parea_bw, y2-vs-u1+parea_bw if indices[:lvhvt]
        delta = params[:pex_delta] || u1*5
        create_box indices[:pex], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:pex]
        delta = delta + delta
        create_box indices[:ar], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:ar]
        if indices[:nwl] &amp;&amp; use_nwell
          if one = params[:nwl_bw] #         one = u1*6.25
            if indices[:pex]
              create_box indices[:nwl],  x1-delta-one, y1+vs-u1/2-delta-u1-one, [offset-gl+delta+one, x1-delta+4*one].max, 
                     [y2-vs+u1/2+delta+u1+one, y1+vs-u1/2-delta-u1+4*one].max # just for tiascr130?
            else
              create_box indices[:nwl],  x1-delta-one, y1+vs+u1-delta-one, offset-gl+delta+one, y2-vs-u1+delta+one
            end
          else
            if n % 2 == 0
              create_box indices[:nwl], x1-vs, y1-u1-u1/2, offset-gl +2*u1, y2
            else
              create_box indices[:nwl], x1-vs, y1, offset-gl +2*u1, y2+u1+u1/2
            end
          end
        end
      }
    end
  end

  class MinedaResistor &lt; MinedaPCellCommon
  
    include RBA
    def initialize
      # Important: initialize the super class
      super
      param(:with_via, TypeBoolean, "Put Via over contacts", :default =&gt; true, :hidden =&gt; false)
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def parameters_from_shape_impl
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end

    def create_contacts indices, w, x0, y, vs, u1, fill_metal=true
      contact = indices[:pcont] || indices[:dcont] || indices[:nsubcont]
      pitch = vs+u1/4  # cnt distance &gt; 5 um
      n = (w/pitch).to_i
      if n &lt;= 1
        insert_cell contact, x0, y, true
        insert_cell indices[:via], x0, y if !defined?(with_via) || with_via
      else
        offset = w- pitch*n
        (x0-w/2 + offset/2 + pitch/2).step(x0+w/2-vs/2, pitch){|x|
          # insert_cell indices, :via, x, y, vs, u1, false
          insert_cell contact, x0, y, true
          insert_cell indices[:via], x0, y if !defined?(with_via) || with_via
        }
        create_box indices[:m1], x0-w/2, y-vs/2, x0+w/2, y+vs/2
        #vs2 = vs + u1/4
        #create_box indices[:m2], x0-w/2, y-vs2/2, x0+w/2, y+vs2/2
      end
    end
       
    def produce_impl indices, header_outside, vs, u1, params={}
      res_body = indices[:pol] || indices[:diff] || indices[:nwl]
      rw = (w/layout.dbu).to_i
      rrl = (l/layout.dbu).to_i
      sp = (s/layout.dbu).to_i
      ms = (m/layout.dbu).to_i
      cs = params[:contact_size] || vs
      rrl = rrl - (vs - cs)
      rw_ho = rw*header_outside
      rl = rrl - (sp+rw)*(n-1) -rw_ho
      sl = [(rl/n/u1).to_i*u1, ms-2*rw].min
      if sl*n + (sp+rw)*(n-1) == rrl
        r = 0
      else
        sl = [sl + u1, ms-2*rw].min
        r = rrl - sl*(n-1) - (sp+rw)*(n-1)
        if r &lt;= 0 &amp;&amp; sl &gt; ms-2*rw
          rl = rrl - sp*(n-2)
          set_n n - 1
        end
      end
      puts "rw=#{rw}, rrl = #{rrl}, rl = #{rl}, n = #{n}, sp=#{sp}, sl = #{sl}, r = #{r}"
      prev_x = nil
      xmax = ymax = -10000000
      ymin = 10000000
      for i in 0..n-1
        offset = vs/2 + (sp+rw)*i
        r = sl
        if i == n - 1 # rl - sl*(i+1) &lt; 0
          r = rl - sl*i
        end
        puts "offset=#{offset}, r=#{r} for i=#{i}"
        if i % 2 == 0
          x = offset
          if i == 0 
            points = [Point::new(x, -rw_ho), Point::new(x, vs+r)]
            y = vs/2-rw_ho
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymin = [ho ? y + vs/2 : y - vs/2, ymin].min
            points = [Point::new(x, vs-rw_ho-(vs-cs)/2), Point::new(x, vs+r + (vs-cs)/2)]
          else
            points = [Point::new(x, vs-rw_ho), Point::new(x, vs+r + (vs-cs)/2)]
          end
          cell.shapes(indices[:res]).insert(Path::new(points, rw, 0, 0))    
          if i == n-1
            points = [Point::new(x, (n == 1 ? -rw_ho : vs)), Point::new(x, vs+r+vs)]
            y =  vs+r+vs/2
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymax = [y+vs/2, ymax].max
          end
          cell.shapes(res_body).insert(Path::new(points, rw, 0, 0))
       
          if prev_x
            y = vs - rw/2
            points = [Point::new(x, y), Point::new(prev_x, y)]
            cell.shapes(res_body).insert(Path::new(points, rw, rw/2, rw/2))
            cell.shapes(indices[:res]).insert(Path::new(points, rw, rw/2, rw/2))
            ymax = [y+rw/2, ymax].max 
          end  
        else
          points = [Point::new(offset, vs+(sl-r)-(vs-cs)/2), Point::new(offset, vs+sl)]
          cell.shapes(indices[:res]).insert(Path::new(points, rw, 0, 0))
          if i == n-1
            points = [Point::new(offset, sl-r), Point::new(offset, vs+sl)]
            x = offset
            y = vs+sl-r-vs/2
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymax = [y+vs/2, ymax].max
            ymin = [ho ? y+vs/2+u1/4 : y-vs/2, ymin].min
          end
          cell.shapes(res_body).insert(Path::new(points, rw, 0, 0))

          if prev_x
            x = offset
            y = vs + sl + rw/2
            points = [Point::new(x, y), Point::new(prev_x, y)]
            cell.shapes(res_body).insert(Path::new(points, rw, rw/2, rw/2))
            cell.shapes(indices[:res]).insert(Path::new(points, rw, rw/2, rw/2))
            ymax = [y+rw/2, ymax].max 
          end
        end
        prev_x = offset 
        xmax = [x + [rw/2, vs/2].max, xmax].max
        puts "[xmax,ymax] = #{[xmax,ymax].inspect}"
      end 
      # puts "n=#{n}"
      [[[vs/2-rw/2, 0].min, [(ho||n&lt;=2) ? 0 : vs - rw, ymin].min, xmax, ymax], rw_ho]
    end
  end

  class MinedaCapacitor &lt; MinedaPCellCommon
    include RBA
    def initialize 
      # Important: initialize the super class --- don't know if this is really necessary
      super
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end
    
    def create_contacts_horizontally indices, x1, x2, y0, vs, u1, fill_metal=true
      pitch = vs+u1 # +u1/2+u1/4
      n = ((x2+u1-x1)/pitch).to_i
      offset = x2+u1-x1-pitch*n
      (offset/2 + x1+vs/2..x2-vs/2).step(pitch){|x|
        # insert_cell indices, index, x, y1, vs, u1, fill_metal
        if indices[:pol]
          insert_cell indices[:pcont], x, y0
        else
          insert_cell indices[:dcont], x, y0
        end
        insert_cell indices[:via], x, y0
      }
    end
    
    def create_contacts_vertically indices, x0, y1, y2, vs, u1, fill_metal=true
      pitch = vs+u1  # +u1/2+u1/4
      n = ((y2+u1-y1)/pitch).to_i
      offset = y2+u1-y1-pitch*n
      (offset/2+y1+vs/2..y2-vs/2).step(pitch){|y|
        # insert_cell indices, index, x1, y, vs, u1, fill_metal
        if indices[:via2]
          insert_cell indices[:via2], x0, y
        else
          if indices[:pol]
            insert_cell indices[:pcont], x0, y
          else
            insert_cell indices[:dcont], x0, y
          end
          insert_cell indices[:via], x0, y
        end
      }
    end
    
    def instantiate index, x, y
      CellInstArray.new(index, Trans.new(x, y))
    end
  end
  
  class  MinedaDiff_cap &lt; MinedaCapacitor
    def initialize
      super
      param(:cval, TypeDouble, "Capacitor value", :default =&gt; 0, :hidden=&gt; true)
      param(:polcnt_outside, TypeBoolean, "Poly contact outside?", :default =&gt; true, :hidden =&gt; false)
    end
        
    def display_text_impl
      # Provide a descriptive text for the cell
      "Diff Capacitor\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,C=#{cval.to_s})"
    end
    
    def produce_impl indices, vs, u1, area_index=nil, well_index=nil, params={}
      cw = (w/layout.dbu).to_i
      cl = (l/layout.dbu).to_i
      u2 = u1 + u1

      create_box indices[:diff], 0, -u1, cw, cl+u1+vs
      create_box indices[:cap], 0, 0, cw, cl
      # create_box indices[:cap], 0, 0, cw, cl+u1+vs
      create_box area_index, -u1/2, -u1-u1/2, cw + u1/2, cl + u1/2 + vs + u1
      well_diff_enc = params[:wd_enc] || u1*5
      if well_index
        if nsub_cont 
          create_box well_index, [-well_diff_enc, -vs-u1/2-u2].min, -u1-well_diff_enc,
                          cw + well_diff_enc, [cl + well_diff_enc + vs + u1, cl+u2+vs + u2].max
          insert_cell indices[:nsubcont], -vs-u1/2, cl+u2+vs
        else
          x0 = -well_diff_enc
          x0 = [x0, -u2-vs].min if polcnt_outside
          create_box well_index, x0, -u1-well_diff_enc, cw + well_diff_enc, cl + well_diff_enc + vs + u1
        end
      end
      
      if polcnt_outside
        create_box indices[:pol], -u2-vs, 0, cw + u1, cl
        create_contacts_vertically indices, -u1-vs/2, 0, cl, vs, u1, true # false
      else
        create_box indices[:pol], -u1, 0, cw + u1, cl
        create_contacts_vertically indices, u1+vs/2, 0, cl, vs, u1, true # false
      end
      indices[:pol] = nil # this tells create_contacts_horizontally to use dcont
      create_contacts_horizontally indices, 0, cw, u1/2+cl+u1, vs, u1, true # false
      # insert_cell indices, nsubcont_index, 0, cl+2*u1+vs, vs, u1
      # insert_cell indices, :diff, 0, cl+2*u1+vs, vs, u1
      # insert_cell indices, :cnt, 0, cl+2*u1+vs, vs, u1
      #          points = [Point::new(offset, vs), Point::new(offset, vs/2+r)]
      #          cell.shapes(pol_index).insert(Path::new(points, rw, vs, vs))
      #          cell.shapes(res_index).insert(Path::new(points, rw, vs/4, vs/4))
    end
  end
  
  class MinedaPoly_cap &lt; MinedaCapacitor
    def initialize
      super
      param(:cval, TypeDouble, "Capacitor value", :default =&gt; 0, :hidden=&gt; true)
    end
  
    def display_text_impl
      # Provide a descriptive text for the cell
      "Poly Capacitor\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,C=#{cval.to_s})"
    end
    
    def produce_impl indices, vs, u1
      cw = (w/layout.dbu).to_i
      cl = (l/layout.dbu).to_i
      u2 = u1 + u1
      offset = vs+ u2+u1/2+u1/8
      create_box indices[:m1], 0, 0, offset + cw +u1, cl
      create_box indices[:cap], offset, 0, offset + cw, cl
      create_box indices[:pol], offset, -u1, offset + cw , cl+u2+vs
      create_contacts_horizontally indices, offset,  offset + cw, cl + vs/2 + u1, vs, u1
    end
  end
  
  class MinedaSlit_cap &lt; MinedaCapacitor
    # include MinedaPCell
    def display_text_impl
      "Slit capacitor\r\n(L=#{(us*nc).to_s}um,W=#{(us*nr).to_s}um, C=#{cval.to_s}"
    end
    def draw_unit index, x, y, u
      create_box index, x-u/2, y-u/2, x+u/2, y+u/2
    end
    def produce_impl(indices, vs, u1, usize, nc, nr, slit_length, slit_width, csq)
      (0..(hp ? nc: nc-1)).each{|i|
        (0..nr-1).each{|j|
          puts [i, j].inspect
          x = i*usize + (hp ? 0 : usize/2)
          y = j*usize + usize/2
          draw_unit(indices[:m1], x, y, usize -  slit_width)
          draw_unit(indices[:m1], x - usize/2 + csq/2, y - usize/2 + csq/2, csq)
          draw_unit(indices[:m1], x + usize/2 - csq/2, y - usize/2 + csq/2, csq)
          draw_unit(indices[:m1], x - usize/2 + csq/2, y + usize/2 - csq/2, csq)
          draw_unit(indices[:m1], x + usize/2 - csq/2, y + usize/2 - csq/2, csq)
        }
      }
      us2 = usize/2
      if hp # high precision
         create_box indices[:m1], -us2,  0, nc*usize + us2, slit_width
         create_box indices[:m1], -us2,  nr*usize, nc*usize + us2, nr*usize - slit_width
         create_box indices[:pol], 0, -us2, nc*usize, nr*usize + us2 
         create_box indices[:m1], -us2, 0, -us2 + slit_width, nr*usize   
         create_box indices[:m1], nc*usize + us2, 0, nc*usize + us2 - slit_width, nr*usize
         create_box indices[:cap], 0, 0, nc*usize, nr*usize
      else
        create_box indices[:pol], 0, 0, nc*usize, nr*usize
        create_box indices[:cap], slit_width, slit_width, nc*usize-slit_width, nr*usize-slit_width
      end
    end
  end
  
  class MinedaFinger_cap &lt; MinedaCapacitor
    # include MinedaPCell
    def display_text_impl
      "Finger capacitor\r\n(L=#{fl.round(3)}um,W=#{(fw*nf + fg*(nf-1)).round(3)}um, C=#{cval.to_s}"
    end
    def draw_fingers index, fl, fw, fg, nf, flag
      pitch = (fw + fg)*2
      y = 0
      for i in 0..((nf+1)/2).to_i - 1 do
        x = flag ? -fg-fw/2 : fl+fg+fw/2
        if y &gt; 0
          points = [Point::new(x, y), Point::new(x, y - pitch)]
          cell.shapes(index).insert(Path::new(points, fw, fw/2, fw/2))
        end
        points = flag ? [Point::new(x, y), Point::new(fl, y)] : [Point::new(0, y), Point::new(x, y)]
        cell.shapes(index).insert(Path::new(points, fw, 0, 0))
        y = y + pitch
      end
      y = fw + fg 
      x = nil
      for i in ((nf+1)/2).to_i..(nf-1) do
        x = flag ? fl+fg+fw/2 : -fg-fw/2
        if y &gt; fw + fg
          points = [Point::new(x, y), Point::new(x, y - pitch)]
          cell.shapes(index).insert(Path::new(points, fw, fw/2, fw/2))
        end
        points = flag ? [Point::new(0, y), Point::new(x, y)] : [Point::new(x, y), Point::new(fl, y)]
        cell.shapes(index).insert(Path::new(points, fw, 0, 0))
        y = y + pitch
      end
      [x, fw + fg, y - pitch]
    end
    def produce_impl(indices, vs, u1, finger_length, finger_width, finger_gap, nf)
      # super indices, vs, u1, finger_length, finger_width, finger_gap, nf
      x0, y0, y1 = draw_fingers indices[:m2], finger_length, finger_width, finger_gap, nf, true
      create_contacts_vertically indices, x0, y0, y1, vs, u1
      x1, y0, y1 = draw_fingers indices[:m3], finger_length, finger_width, finger_gap, nf, false
      create_contacts_vertically indices, x1, y0, y1, vs, u1
      create_box indices[:cap], 0, -finger_width/2, finger_length, finger_width*nf + finger_gap*(nf-1) - finger_width/2
    end
  end
end
##############################################################################################
</text>
</klayout-macro>
