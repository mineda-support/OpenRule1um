<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>Common macro library for PCells</description>
 <version/>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>ruby</interpreter>
 <dsl-interpreter-name/>
 <text># coding: utf-8
# MinedaPCell v0.42 May 12th, 2022 copy right S. Moriyama (Anagix Corporation)
# 
module MinedaPCell
  version = '0.41'

  include RBA

  class MinedaPCellCommon &lt; PCellDeclarationHelper
    include RBA
    
    def library_cell name, libname, layout
      if cell = layout.cell(name)
        return cell.cell_index
      else
        lib = Library::library_by_name libname
        if lib &amp;&amp; cell = lib.layout.cell(name)
          proxy_index = layout.add_lib_cell(lib, cell.cell_index)
        end
      end
    end

    def create_box index, x1, y1, x2, y2
       cell.shapes(index).insert(Box::new(x1, y1, x2, y2))
    end
    
    def insert_cell via_index, x, y
      via = CellInstArray.new(via_index, Trans.new(x, y))
      inst = cell.insert(via)
    end

    def create_path index, x1, y1, x2, y2, w, be, ee
      points = [Point::new(x1, y1), Point::new(x2, y2)]
      cell.shapes(index).insert(Path::new(points, w, be, ee))
    end
    
    def create_path2 index, x1, y1, x2, y2, x3, y3, w, be, ee
      points = [Point::new(x1, y1), Point::new(x2, y2), Point::new(x3, y3)]
      cell.shapes(index).insert(Path::new(points, w, be, ee))
    end
    
    def create_dcont index, x1, y1, x2, y2, vs
      (y1+vs/2..y2-vs/2).step(vs){|y|
        insert_cell index, x1, y
      }
    end
  end
  
  # The PCell declaration for the Mineda MOSFET
  class MinedaMOS &lt; MinedaPCellCommon
  
    include RBA
    def initialize
      # Important: initialize the super class
      super
      param(:n, TypeInt, "Number of fingers", :default =&gt; 1)
    end

    def coerce_parameters_impl
    
      # We employ coerce_parameters_impl to decide whether the handle or the 
      # numeric parameter has changed (by comparing against the effective 
      # radius ru) and set ru to the effective radius. We also update the 
      # numerical value or the shape, depending on which on has not changed.
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def parameters_from_shape_impl
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end
    
    def coerce_parameters_impl
      set_wtot(w*n)
    end
    
    def produce_impl_core indices, vs, u1, params = {}
      gw = (w/layout.dbu).to_i
      gl = (l/layout.dbu).to_i
      dgl = (dg/layout.dbu).to_i # dumbbell gap length
      xshift = params[:xshift] || vs/2
      yshift = params[:yshift] || vs/2
      u1cut = params[:u1cut] || 0
      offset = 0
      (n+1).times{|i|
        x = offset + vs/2 - xshift
        create_path(indices[:m1], x, vs-yshift+u1, x, vs-yshift+u1-u1cut+[gw, vs].max, vs, 0, 0)
        create_path(indices[:li1], x, vs-yshift+u1, x, vs-yshift+u1-u1cut+[gw, vs].max, u1, 0, 0) if indices[:li1]
        create_dcont(indices[:dcont], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, vs)  
        x = x + vs/2 + gl/2 + dgl
        if i &lt; n
          gate_ext = params[:gate_ext] || vs/2 + u1/8
          create_path(indices[:pol], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, gl, gate_ext, gate_ext) 
          if indices[:gate_impl]
            gim = params[:gate_impl_margin] || vs/2
            create_path(indices[:gate_impl], x, vs-yshift+u1, x, vs-yshift+u1+[gw, vs].max, gl+gim*2, gate_ext+gim, gate_ext+gim) 
          end
        end
        offset = offset + vs + gl + 2*dgl
      }
      if gw &gt; vs
        create_box indices[:diff], -xshift, vs-yshift+u1, offset - gl - 2*dgl - xshift, vs-yshift+u1-u1cut+gw
      else
        create_box indices[:diff], -xshift, vs-yshift+u1+vs/2-gw/2, offset - gl - 2*dgl - xshift, vs-yshift+u1-u1cut+gw+vs/2-gw/2
      end   
      yield -xshift, -yshift, vs*2+gl-xshift, (vs+u1)*2+[gw, vs].max-yshift, gl, dgl
    end
    
    def library_cell name, libname, layout
      if cell = layout.cell(name)
        return cell.cell_index
      else
        lib = Library::library_by_name libname
        cell_index = lib.layout.cell_by_name(name)
        proxy_index = layout.add_lib_cell(lib, cell_index)
      end
    end
  end

  class MinedaNch &lt; MinedaMOS
    include RBA
    
    def display_text_impl
      "Nch\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,n=#{n.to_s}, Total W=#{wtot.round(3)}um)"
    end 
       
    def produce_impl indices, vs, u1, params = {} # NMOS
      produce_impl_core(indices, vs, u1, params){|x1, y1, x2, y2, gl, dgl|
        # create ncon
        wm_offset = wide_metal ? u1 : 0
        x = x1 + vs/2
        pcont_dy = params[:pcont_dy] || u1/4
        y = y2 - vs/2 + pcont_dy
        if wide_metal
          x = x - u1
          y = y + u1/2 
        end
        if with_pcont
          pol_width = params[:pol_width] || u1 + u1/4
          if n == 1 &amp;&amp; !with_sdcont
            insert_cell indices[:pcont], x1+vs+dgl+gl/2, y
            insert_cell indices[:via], x1+vs+dgl+gl/2, y if with_via
            create_path indices[:pol], x1+vs+dgl+gl/2, y, x1+vs+dgl+gl/2, y2-vs, pol_width, 0,0
          else
            insert_cell indices[:pcont], x, y
            insert_cell indices[:via], x, y if with_via
            y = y - u1/2
            create_path2 indices[:pol], x, y, x1+vs+u1/2+dgl, y, x1+vs+u1/2+dgl, y2-vs, pol_width, 0, 0
          end
        end
        offset = x1
        top = nil
        bottom = nil
        prev_pol = nil
        (n+1).times{|i|
          x = offset + vs/2
          y = y2+u1-vs-u1/2
          create_path indices[:pol], prev_pol-vs/2-gl-dgl, y , x-vs/2-dgl, y, u1, 0, 0 if prev_pol
          prev_pol = x if i &gt;= 1
          if i % 2 == 0
            # first s/d and via
            y = y1+vs/2 - wm_offset
            if with_sdcont || n != 1
              insert_cell indices[:via], x, y if with_via &amp;&amp; with_sdcont
              create_path indices[:m1], x, y, x, y1+vs+2*u1, u1, 0, 0
            end
            if top
              create_path indices[:m1], top, y, x, y, u1, u1/2, u1/2
            end
            top = x
          else
            # second s/d and via
            if n == 1
              insert_cell indices[:via], x, y2-vs/2 + (wide_metal ? u1/2 : 0) if with_via &amp;&amp; with_sdcont
            else
              insert_cell indices[:via], x, y2+u1-vs/2 if with_via &amp;&amp; with_sdcont
            end
            create_path indices[:m1], x, y2-vs-2*u1 - wm_offset, x, y2+u1-vs/2, u1, 0, 0 if with_sdcont || n != 1
            if bottom
              y = y2+u1-vs/2
              create_path indices[:m1], bottom, y, x, y, u1, u1/2, u1/2
            end
            bottom = x
          end
          offset = offset + vs + gl + 2*dgl
        }
        offset = offset - 2*dgl
        # psubcont and via
        psubcont_dx = params[:psubcont_dx] || 0
        psubcont_dy = params[:psubcont_dy] || u1/2 + u1
        x = offset - gl - vs/2 + (with_via ? u1/2 : 0) + psubcont_dx
        if with_psubcont &amp;&amp; use_pwell
          if n % 2 == 0
            y = y2 - vs/2 + psubcont_dy
          else
            y = y1 + vs/2 - psubcont_dy
            y = y - u1/2 if wide_metal
          end
          insert_cell indices[:psubcont], x, y if indices[:psubcont] 
          insert_cell indices[:via], x, y if with_via
        end
        #create_box indices[:narea], x1-u1, y1+vs+u1/2, offset-gl+u1, y2-vs-u1/2
        narea_bw = params[:narea_bw] || u1 + u1/4
        create_box indices[:narea], x1-narea_bw, y1+vs+u1-narea_bw, offset-gl+narea_bw, y2-vs-u1+narea_bw
        if indices[:nex]
          delta = u1*5
          create_box indices[:nex], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1
          delta = delta + delta
          create_box indices[:ar], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:ar]
        end
         if indices[:pwl] &amp;&amp; use_pwell
           if one = params[:pwl_bw] #        one = u1*6.25
             create_box indices[:pwl], x1-delta-one, [y1+vs-u1/2-delta-u1-one, y2-vs+u1/2+delta+u1-4*one].min,
                     [offset-gl+delta+one, x1-delta+4*one].max, y2-vs+u1/2+delta+u1+one
           end
        end
      }
    end
  end
  
  class MinedaPch &lt; MinedaMOS
    include RBA
    
    def display_text_impl
      "Pch\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,n=#{n.to_s}, Total W=#{wtot.round(3)}um)"
    end
        
    def produce_impl indices, vs, u1, params = {} # PMOS
      produce_impl_core(indices, vs, u1, params){|x1, y1, x2, y2, gl, dgl|
        # create pcont
        wm_offset = wide_metal ? vs/2 : 0
        x = x1 + vs/2
        pcont_dy = params[:pcont_dy] || -u1/4
        y = y1 + vs/2 + pcont_dy
        if wide_metal
          x = x - u1
          y = y - u1/2
        end
        if with_pcont
          pol_width = params[:pol_width] || u1 + u1/4
          if n == 1 &amp;&amp; !with_sdcont
            insert_cell indices[:pcont], x1+vs+dgl+gl/2, y
            insert_cell indices[:via], x1+vs+dgl+gl/2, y if with_via
            create_path indices[:pol], x1+vs+dgl+gl/2, y, x1+vs+dgl+gl/2, y1+vs, pol_width, 0,0
          else
            insert_cell indices[:pcont], x, y
            insert_cell indices[:via], x, y if with_via
            y = y + u1/2
            create_path2 indices[:pol], x, y, x1+vs+u1/2+dgl, y, x1+vs+u1/2+dgl, y1+vs, pol_width, 0, 0
          end
        end
        offset = x1
        top = nil
        bottom = nil
        prev_pol = nil
        (n+1).times{|i|
          x = offset + vs/2
          create_path indices[:pol], prev_pol-vs/2-gl-dgl, y1+u1/2+vs/2, x-vs/2-dgl, y1+u1/2+vs/2, u1, 0, 0 if prev_pol
          prev_pol = x  if i &gt;=1   
          if i % 2 == 0
            # first s/d and via
            if with_sdcont || n != 1
              insert_cell indices[:via], x, y2-vs/2 + wm_offset if with_via &amp;&amp; with_sdcont
              create_path indices[:m1], x, y2-vs-2*u1, x, y2-vs/2 + wm_offset, u1, 0, 0
            end
            if top
              y = y2-vs/2 + wm_offset
              create_path indices[:m1], top, y, x, y, u1, u1/2, u1/2
            end
            top = x
          else
            # second s/d and via
            if n == 1
              insert_cell indices[:via], x, y1+vs/2 - (wide_metal ? u1/2 : 0) if with_via &amp;&amp; with_sdcont
            else
              insert_cell indices[:via], x, y1-u1+vs/2 if with_via &amp;&amp; with_sdcont
            end
            create_path indices[:m1], x, y1-u1+vs/2, x, y1+vs+2*u1, u1, 0, 0 if with_sdcont || n != 1
            if bottom
              create_path indices[:m1], bottom, y1-u1+vs/2, x, y1 -u1+vs/2, u1, u1/2, u1/2
            end
            bottom = x
          end
          offset = offset + vs + gl + 2*dgl
        }
         # nsubcont and via
        if with_nsubcont &amp;&amp; use_nwell
          # nsubcont_dx = params[:nsubont_dx] || 0
          nsubcont_dy = params[:nsubcont_dy] ||  u1/2 + u1
          offset = offset - 2*dgl
          x = offset - gl - vs/2 + (with_via ? u1/2 : 0)
          if n % 2 == 0
            y = y1 + vs/2 - nsubcont_dy - (wide_metal ? u1 : 0)
          else
            y = y2 - vs/2 + nsubcont_dy + wm_offset
          end
          y = y + u1/2 if wide_metal
          insert_cell indices[:nsubcont], x, y if indices[:nsubcont] 
          insert_cell indices[:via], x, y if with_via
        end
        parea_bw = params[:parea_bw] || u1 + u1/4
        create_box indices[:parea], x1-parea_bw, y1+vs+u1-parea_bw, offset-gl+parea_bw, y2-vs-u1+parea_bw
        delta = u1*5
        create_box indices[:pex], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:pex]
        delta = delta + delta
        create_box indices[:ar], x1-delta, y1+vs-u1/2-delta-u1, offset-gl+delta, y2-vs+u1/2+delta+u1 if indices[:ar]
        if indices[:nwl] &amp;&amp; use_nwell
          if one = params[:nwl_bw] #         one = u1*6.25
            create_box indices[:nwl],  x1-delta-one, y1+vs-u1/2-delta-u1-one, [offset-gl+delta+one, x1-delta+4*one].max, 
                     [y2-vs+u1/2+delta+u1+one, y1+vs-u1/2-delta-u1+4*one].max
          else
            if n % 2 == 0
              create_box indices[:nwl], x1-vs, y1-u1-u1/2, offset-gl +2*u1, y2
            else
              create_box indices[:nwl], x1-vs, y1, offset-gl +2*u1, y2+u1+u1/2
            end
          end
        end
      }
    end
  end

  class MinedaResistor &lt; MinedaPCellCommon
  
    include RBA
    def initialize

      # Important: initialize the super class
      super
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def parameters_from_shape_impl
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end

    def create_contacts indices, w, x0, y, vs, u1, fill_metal=true
      if indices[:pol]
        contact = indices[:pcont]
      else
        contact = indices[:dcont]
      end
      pitch = vs+u1/4  # cnt distance &gt; 5 um
      n = (w/pitch).to_i
      if n &lt;= 1
        insert_cell contact, x0, y
        insert_cell indices[:via], x0, y
      else
        offset = w- pitch*n
        (x0-w/2 + offset/2 + pitch/2).step(x0+w/2-vs/2, pitch){|x|
          # insert_cell indices, :via, x, y, vs, u1, false
          insert_cell contact, x0, y
          insert_cell indices[:via], x0, y   
        }
        create_box indices[:m1], x0-w/2, y-vs/2, x0+w/2, y+vs/2
        #vs2 = vs + u1/4
        #create_box indices[:m2], x0-w/2, y-vs2/2, x0+w/2, y+vs2/2
      end
    end
       
    def produce_impl indices, header_outside, vs, u1, params={}
      res_body = indices[:pol] || indices[:diff]
      rw = (w/layout.dbu).to_i
      rrl = (l/layout.dbu).to_i
      sp = (s/layout.dbu).to_i
      ms = (m/layout.dbu).to_i
      rw_ho = rw*header_outside
      rl = rrl - (sp+rw)*(n-1) -rw_ho
      sl = [(rl/n/u1).to_i*u1, ms-2*rw].min
      if sl*n + (sp+rw)*(n-1) == rrl
        r = 0
      else
        sl = [sl + u1, ms-2*rw].min
        r = rrl - sl*(n-1) - (sp+rw)*(n-1)
        if r &lt;= 0 &amp;&amp; sl &gt; ms-2*rw
          rl = rrl - sp*(n-2)
          set_n n - 1
        end
      end
      puts "rw=#{rw}, rrl = #{rrl}, rl = #{rl}, n = #{n}, sp=#{sp}, sl = #{sl}, r = #{r}"
      prev_x = nil
      xmax = ymax = -10000000
      ymin = 10000000
      header_offset = params[:header_offset] || 0
      for i in 0..n-1
        offset = vs/2 + (sp+rw)*i
        r = sl
        if i == n - 1 # rl - sl*(i+1) &lt; 0
          r = rl - sl*i
        end
        puts "offset=#{offset}, r=#{r} for i=#{i}"
        if i % 2 == 0
          x = offset
          points = [Point::new(x, vs-rw_ho), Point::new(x, vs+r)]
          cell.shapes(indices[:res]).insert(Path::new(points, rw, 0, 0))    
          if i == 0 
            points = [Point::new(x, -rw_ho + header_offset), Point::new(x, vs+r - header_offset)]
            y = vs/2-rw_ho + header_offset
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymin = [ho ? y + vs/2 : y - vs/2, ymin].min
          end
          if i == n-1
            points = [Point::new(x, (n == 1 ? -rw_ho : vs) - header_offset), Point::new(x, vs+r+vs)]
            y =  vs+r+vs/2 - header_offset
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymax = [y+vs/2, ymax].max
          end
          cell.shapes(res_body).insert(Path::new(points, rw, 0, 0))
       
          if prev_x
            y = vs - rw/2
            points = [Point::new(x, y), Point::new(prev_x, y)]
            cell.shapes(res_body).insert(Path::new(points, rw, rw/2, rw/2))
            cell.shapes(res_body).insert(Path::new(points, rw, rw/2, rw/2))
            ymax = [y+rw/2, ymax].max 
          end  
        else
          points = [Point::new(offset, vs+(sl-r)), Point::new(offset, vs+sl)]
          cell.shapes(indices[:res]).insert(Path::new(points, rw, 0, 0))
          if i == n-1
            points = [Point::new(offset, sl-r), Point::new(offset, vs+sl)]
            x = offset
            y = vs+sl-r-vs/2 + header_offset
            # insert_cell indices, :via, x, y, vs, u1
            # insert_cell indices, :cnt, x, y, vs, u1
            # insert_cell indices, :diff, x, y, vs, u1
            create_contacts indices, rw, x, y, vs, u1
            ymax = [y+vs/2, ymax].max
            ymin = [ho ? y+vs/2+u1/4 : y-vs/2, ymin].min
          end
          cell.shapes(res_body).insert(Path::new(points, rw, 0, 0))

          if prev_x
            x = offset
            y = vs + sl + rw/2
            points = [Point::new(x, y), Point::new(prev_x, y)]
            cell.shapes(res_body).insert(Path::new(points, rw, rw/2, rw/2))
            cell.shapes(indices[:res]).insert(Path::new(points, rw, rw/2, rw/2))
            ymax = [y+rw/2, ymax].max 
          end
        end
        prev_x = offset 
        xmax = [x + [rw/2, vs/2].max, xmax].max
        puts "[xmax,ymax] = #{[xmax,ymax].inspect}"
      end 
      # puts "n=#{n}"
      if indices[:hpol]
        yield vs, rw, prev_x, sl
      end
      [[[vs/2-rw/2, 0].min, [(ho||n&lt;=2) ? 0 : vs - rw, ymin].min, xmax, ymax], rw_ho]
    end
  end

  class MinedaCapacitor &lt; MinedaPCellCommon
    include RBA
    def initialize 
      # Important: initialize the super class --- don't know if this is really necessary
      super
    end
    
    # default implementation
    def can_create_from_shape_impl
      false
    end
    
    def transformation_from_shape_impl
      # I「Create PCell from shape（形状からPCellを作成）」プロトコルを実装します。
      # 変形を決定するために、図形のバウンディングボックスの中心を使用します。
      Trans.new(shape.bbox.center)
    end
    
    def create_contacts_horizontally indices, x1, x2, y0, vs, u1, fill_metal=true
      pitch = vs+u1 # +u1/2+u1/4
      n = ((x2+u1-x1)/pitch).to_i
      offset = x2+u1-x1-pitch*n
      (offset/2 + x1+vs/2..x2-vs/2).step(pitch){|x|
        # insert_cell indices, index, x, y1, vs, u1, fill_metal
        insert_cell indices[:dcont], x, y0
        insert_cell indices[:via], x, y0
      }
    end
    
    def create_contacts_vertically indices, x0, y1, y2, vs, u1, fill_metal=true
      pitch = vs+u1  # +u1/2+u1/4
      n = ((y2+u1-y1)/pitch).to_i
      offset = y2+u1-y1-pitch*n
      (offset/2+y1+vs/2..y2-vs/2).step(pitch){|y|
        # insert_cell indices, index, x1, y, vs, u1, fill_metal
        insert_cell indices[:dcont], x0, y
        insert_cell indices[:via], x0, y
      }
    end
    
    def instantiate index, x, y
      CellInstArray.new(index, Trans.new(x, y))
    end
  end
  
  class  MinedaDiff_cap &lt; MinedaCapacitor
    def initialize
      super
      param(:cval, TypeDouble, "Capacitor value", :default =&gt; 0, :hidden=&gt; true)
    end
        
    def display_text_impl
      # Provide a descriptive text for the cell
      "Diff Capacitor\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,C=#{cval.round(3)})"
    end
    
    def produce_impl indices, vs, u1, area_index=nil, well_index=nil
      cw = (w/layout.dbu).to_i
      cl = (l/layout.dbu).to_i
      u2 = u1 + u1

      create_box indices[:diff], 0, -u1, cw, cl+u2+vs
      create_box area_index, -u1/2, -u1-u1/2, cw + u1/2, cl + u1/2 + vs + u2
      create_box well_index, -u1*5, -u1-u1*5, cw + u1*5, cl + u1*5 + vs + u2
      create_box indices[:pol], -u1, 0, cw + u1, cl
      create_box indices[:cap], 0, 0, cw, cl 
      create_contacts_vertically indices, u1+vs/2, 0, cl, vs, u1, true # false
      create_contacts_horizontally indices, 0, cw, u1/2+cl+u1, vs, u1, true # false
      # insert_cell indices, nsubcont_index, 0, cl+2*u1+vs, vs, u1
      # insert_cell indices, :diff, 0, cl+2*u1+vs, vs, u1
      # insert_cell indices, :cnt, 0, cl+2*u1+vs, vs, u1
      #          points = [Point::new(offset, vs), Point::new(offset, vs/2+r)]
      #          cell.shapes(pol_index).insert(Path::new(points, rw, vs, vs))
      #          cell.shapes(res_index).insert(Path::new(points, rw, vs/4, vs/4))
    end
  end
  
  class MinedaPoly_cap &lt; MinedaCapacitor
    def initialize
      super
      param(:cval, TypeDouble, "Capacitor value", :default =&gt; 0, :hidden=&gt; true)
    end
  
    def display_text_impl
      # Provide a descriptive text for the cell
      "Poly Capacitor\r\n(L=#{l.round(3)}um,W=#{w.round(3)}um,C=#{cval.round(3)})"
    end
    
    def produce_impl indices, vs, u1
      cw = (w/layout.dbu).to_i
      cl = (l/layout.dbu).to_i
      u2 = u1 + u1
      offset = vs+ u2+u1/2+u1/8
      create_box indices[:m1], 0, 0, offset + cw +u1, cl
      create_box indices[:cap], offset, 0, offset + cw, cl
      create_box indices[:pol], offset, -u1, offset + cw , cl+u2+vs
      create_contacts_horizontally indices, offset,  offset + cw, cl + vs/2 + u1, vs, u1
    end
  end
end
##############################################################################################
</text>
</klayout-macro>
