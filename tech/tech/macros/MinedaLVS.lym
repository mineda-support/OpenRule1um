<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>Common macro library for LVS preprocessor </description>
 <version/>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>true</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>ruby</interpreter>
 <dsl-interpreter-name/>
 <text># Mineda LVS preprocessor v0.5 June 6th copy right by S. Moriyama (Anagix Corporation)

class MinedaLVS
  include RBA # unless $0 == __FILE__
  require 'fileutils'
  require 'yaml'
  def get_params netlist
    p = {}
    File.open(netlist, 'r:Windows-1252').read.encode('UTF-8', invalid: :replace).each_line{|l|
      l.gsub! 00.chr, ''
      if l.upcase =~/\.PARAM\S* (\S+.*$)/
        params = $1
        params.split.each{|equation|
          equation =~ /(\S+) *= *(\S+)/
          p[$1] = $2
        }
      end
    }
    p
  end

  def expand_file file, lines
    # File.open(file, 'r:Windows-1252').read.encode('UTF-8', invalid: :replace).each_line{|l|
    File.open(file, 'r:Windows-1252').read.encode('UTF-8').gsub(181.chr(Encoding::UTF_8), 'u').each_line{|l|
      if l.chop =~ /.inc\S* +(\S+)/
        include_file = $1
        lines &lt;&lt; '*' + l
        if File.exist? include_file
          lines = expand_file(include_file, lines)
        end
      else
        lines &lt;&lt; l
      end
    }
    # puts "*** #{file}:"
    # puts lines
    lines
  end

  def lvs_go target_technology, settings = {}
    app = Application.instance
    mw = app.main_window
    cv = mw.current_view.active_cellview
    raise "You are running #{target_technology} version of 'get_reference' against #{cv.technology} layout" unless cv.technology == target_technology
    raise 'Please save the layout first' if cv.nil? || cv.filename.nil? || cv.filename == ''
    cell = cv.cell
    netlist = QFileDialog::getOpenFileName(mw, 'Netlist file', File.dirname(cv.filename), 'netlist(*.net *.cir *.spc *.sp)')
    if netlist &amp;&amp; netlist.strip != ''
      netlist = netlist.force_encoding('UTF-8')
      # netlist = '/home/seijirom/Dropbox/work/LRmasterSlice/comparator/COMP_NLF.net'
      # raise "#{netlist} does not exist!" unless File.exist? netlist
      Dir.chdir File.dirname(cv.filename).force_encoding('UTF-8')
      ext_name = File.extname cv.filename
      target = File.basename(cv.filename).sub(ext_name, '')
      Dir.mkdir 'lvs_work' unless File.directory? 'lvs_work'
      reference = File.join('lvs_work', "#{target}_reference.cir.txt")
      ref={'target' =&gt; target, 'reference'=&gt; reference, 'netlist'=&gt; netlist, 'schematic' =&gt; netlist.sub('.net', '.asc')}
      File.open(target+'.yaml', 'w'){|f| f.puts ref.to_yaml}
      desc = ''
      cells = []
      circuit_top = nil
      device_class = {}
      lines = expand_file netlist, ''
      params = get_params netlist
      c = File.open(File.join('lvs_work', File.basename(netlist))+'.txt', 'w:UTF-8')
      lines.each_line{|l|
        l.gsub! 00.chr, ''
        l.tr! "@%-", "$$_"
        c.puts l
        # if l=~ /(\S+)@or1_stdcells_v1/
        #  cells &lt;&lt; $1 unless cells.include? $1
        #  l.sub! '@', '$'
        # elsif l =~ /^ *\.inc/ || l =~ /^ *([iI]|[vV])/
        #   l.sub! /^/, '*'
        #  els
        if l =~ /^\.ends/
          inside_subckt = false
        elsif l=~/^\.subckt *(\S+)/
          inside_subckt = true
          circuit_top ||= $1
          puts "subcircuit: #{$1}"
        elsif l=~/^(([mM]\S+) *\S+ *\S+ *\S+ *\S+ *(\S+)) *(.*)/
          body = $1
          name=$2
          others = ($4 &amp;&amp; $4.upcase)
          model = $3
          # device_class['NMOS'] = model if model &amp;&amp; model.upcase =~ /NCH|NMOS/
          # device_class['PMOS'] = model if model &amp;&amp; model.upcase =~ /PCH|PMOS/
          p = {}
          others &amp;&amp; others.split.each{|equation|
            if equation =~ /(\S+) *= *{(\S+)}/
              ov = $2
              p[$1] = params[ov.upcase] || ov
            elsif equation =~ /(\S+) *= *(\S+)/
              p[$1] = params[$2] || $2
            end
          }
          if p['M'] &amp;&amp; p['M'] &gt; "1"
            if p['W'] =~ /([^U]+) *(U*)/
              new_w  = "#{$1.to_i * p['M'].to_i}#{$2}"
              puts "Caution for #{name}: w=#{p['W']} replaced with w=#{new_w} because m=#{p['M']}"
              p['W'] = new_w
              p['M'] = '1'
            end
          end   
          # others = p.map{|a| "#{a[0]}=#{a[1]}"}.join ' '
          others = "l=#{p['L']} w=#{p['W']}" # supress other parameters like as, ps, ad and pd
          l = "#{body} #{others}\n"
        elsif !inside_subckt
          if l =~ /^ *[xX]/
            circuit_top ||= '.TOP'
          elsif l =~ /^ *([rR]|[cC])/ || l.downcase =~ /^ *\.global/ 
            # do nothing
          else
            l.sub! /^/, '*'
          end
        else
          if l =~ /{(\S+)}/
            ov = $1
            rv = params[ov.upcase] || ov  #  calculation for ov like (6u*20u) should be implemented
            l.sub! "{#{ov}}", rv
          end
        end
        break if l.upcase.strip == '.END'
        desc &lt;&lt; l.upcase
      }
      circuit_top = circuit_top ? circuit_top.upcase : '.TOP'
      puts "circuit_top =&gt; #{circuit_top}"
      c.close
      File.open(reference, 'w:UTF-8'){|f| 
        f.puts desc
        f.puts '.GLOBAL 0'
        f.puts '.END'
      }
      # slink = File.join('lvs_work', reference+'.txt')
      # File.delete slink if File.exist?(slink) 
      # if /mswin32|mingw/ =~ RUBY_PLATFORM
      #   File.link reference, slink
      # else
      #   File.symlink "../#{File.basename reference}", slink
      # end

      puts "#{reference} created under #{Dir.pwd}"
      ['macros', 'pymacros', 'python', 'ruby', 'drc'].each{|f| FileUtils.rm_rf f if File.directory? f}
      if cells.size &gt; 0
        or1_cells = %[an21 an31 an41 buf1 buf2 buf4 buf8 cinv clkbuf1 clkbuf2 clkinv1 clkinv2 dff1 exnr exor
                     inv1 inv1 ~inv2 inv4 inv8 na21 na212 na222 na31 na41 nr21 nr212 nr222 nr31 or21 or31
                     rff1 sdff1 sff1 srff1 ssff1]
        File.open('lvs_work/lvs_settings.rb', 'w'){|f|
          f.puts 'def lvs_settings'
          f.puts "  same_circuits '#{cell.name}', '#{circuit_top ? circuit_top.upcase : '.TOP'}'"
          cells.each{|c|
            if or1_cells.include? c
              f.puts "  same_circuits '#{c}', '#{c.upcase}$OR1_STDCELLS_V1'"
            end
          }
          f.puts "  netlist.make_top_level_pins"
          f.puts "  netlist.flatten_circuit 'Nch*'"
          f.puts "  netlist.flatten_circuit 'Pch*'"
          f.puts 'end'
        }
      end
      unless File.exist? "lvs_work/#{target}_lvs_settings.rb"
        set_settings cell.name, circuit_top, device_class, "lvs_work/#{target}_lvs_settings.rb", settings
      end
    end
  end

  def set_settings cell_name, circuit_top, device_class, file, settings
    File.open(file, 'w'){|f|
      f.puts 'def lvs_settings'
      f.puts "  same_circuits '#{cell_name}', '#{circuit_top ? circuit_top.upcase : '.TOP'}'" if cell_name
      f.puts "  align"
      settings[:device] &amp;&amp; device_class.merge!(settings[:device])
      device_class.each_pair{|p, q|
        f.puts "  same_device_classes '#{p}', '#{q.upcase}'" if q
      }
      settings[:tolerance] &amp;&amp; settings[:tolerance].each_pair{|d, spec|
        spec.each_pair{|p, v|
          specs = []
          v.each_pair{|name, tol|
            case name
            when :relative
              specs &lt;&lt; ':relative =&gt; ' + tol.to_s
            when :absolute
              specs &lt;&lt; ':absolute =&gt; ' + tol.to_s
            end
          }
          f.puts "  tolerance '#{d}', '#{p}', #{specs.join(', ')}"
        }
      }
      f.puts "  netlist.make_top_level_pins"
      settings[:flatten_circuit] &amp;&amp; settings[:flatten_circuit].each{|c|
        f.puts "  netlist.flatten_circuit '#{c}'"
      }
      f.puts "  netlist.combine_devices"
      f.puts "  schematic.combine_devices"
      f.puts 'end'
    }
  end
end

if nil &amp;&amp; $0 == __FILE__
  settings = {
    device: {HRES: 'RES', RES: 'RES'},
    tolerance: {HRES: {R: {relative: 0.03}},
                RES: {L: {relative: 0.03}, W: {relative: 0.03}},                
                CAP: {C: {relative: 0.03, absolute: 1e-15}}},
    flatten_circuit: ['Nch*', 'Pch*', 'R_poly*', 'HR_poly']
  }
  MinedaLVS.new.set_settings nil, nil, {}, '/dev/stdout', settingsend
end
</text>
</klayout-macro>
